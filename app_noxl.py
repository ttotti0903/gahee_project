
import sys
from pathlib import Path
from typing import Dict
from PySide6.QtWidgets import (
    QApplication, QWidget, QLabel, QLineEdit, QVBoxLayout, QHBoxLayout,
    QPushButton, QTabWidget, QFormLayout, QScrollArea, QMessageBox
)
from PySide6.QtCore import Qt
import calc_core

APP_TITLE = "Concrete Pumping Calculator (No Excel)"
SHEETS = [name for name in dir(calc_core) if name.startswith("compute_")]

class SheetTab(QWidget):
    def __init__(self, sheet_func_name: str, inputs: Dict[str, float], parent=None):
        super().__init__(parent)
        self.sheet_func_name = sheet_func_name
        self.func = getattr(calc_core, sheet_func_name)
        self.input_cells = sorted(inputs.keys()) if inputs else []
        # If no pre-known inputs (shouldn't happen), allow blank
        root = QVBoxLayout(self)

        in_form = QFormLayout()
        self.input_fields: Dict[str, QLineEdit] = {}
        for addr in self.input_cells:
            le = QLineEdit(self)
            le.setPlaceholderText(addr)
            self.input_fields[addr] = le
            in_form.addRow(QLabel(addr), le)

        in_container = QWidget()
        in_container.setLayout(in_form)
        in_scroll = QScrollArea()
        in_scroll.setWidgetResizable(True)
        in_scroll.setWidget(in_container)

        out_form = QFormLayout()
        self.output_fields: Dict[str, QLineEdit] = {}
        # outputs not known here; will populate after compute
        out_container = QWidget()
        out_container.setLayout(out_form)
        out_scroll = QScrollArea()
        out_scroll.setWidgetResizable(True)
        out_scroll.setWidget(out_container)
        self.out_form = out_form

        btns = QHBoxLayout()
        self.calc_btn = QPushButton("Compute")
        self.clear_btn = QPushButton("Clear Inputs")
        btns.addWidget(self.calc_btn)
        btns.addWidget(self.clear_btn)

        root.addWidget(QLabel(f"<b>Sheet:</b> {sheet_func_name.replace('compute_','')}"))
        root.addWidget(QLabel("<b>Inputs</b>"))
        root.addWidget(in_scroll, 1)
        root.addWidget(QLabel("<b>Outputs</b>"))
        root.addWidget(out_scroll, 1)
        root.addLayout(btns)

        self.calc_btn.clicked.connect(self.on_compute)
        self.clear_btn.clicked.connect(self.on_clear)

    def on_clear(self):
        for le in self.input_fields.values():
            le.clear()

    def on_compute(self):
        vals = {}
        for addr, le in self.input_fields.items():
            t = le.text().strip()
            vals[addr] = float(t) if t else 0.0
        try:
            out = self.func(vals)
        except Exception as e:
            QMessageBox.critical(self, "Calculation error", str(e))
            return
        # show outputs
        # clear existing rows
        while self.out_form.rowCount():
            self.out_form.removeRow(0)
        for k in sorted(out.keys()):
            le = QLineEdit(self)
            le.setReadOnly(True)
            le.setText("" if out[k] is None else str(out[k]))
            self.out_form.addRow(QLabel(k), le)

class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(APP_TITLE)
        self.resize(900, 700)

        tabs = QTabWidget()
        # Discover compute functions and infer input cells by introspection
        for name in sorted(SHEETS):
            # We can't introspect inputs from the compiled function easily;
            # so we generate a dummy dict of expected inputs by reading source hints is not trivial.
            # Instead, we embed a small hint file generated by the codegen.
            from sheet_meta import SHEET_INPUTS
            inputs = SHEET_INPUTS.get(name, {})
            tabs.addTab(SheetTab(name, inputs), name.replace("compute_","").title())

        lay = QVBoxLayout(self)
        lay.addWidget(tabs)

def main():
    app = QApplication(sys.argv)
    w = MainWindow()
    w.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
